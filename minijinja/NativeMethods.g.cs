// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = "minijinja_cabi";





        /// <summary>
        ///  Allocates a new and empty MiniJinja environment.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_env* mj_env_new();

        /// <summary>
        ///  Frees a MiniJinja environment.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_env_free(mj_env* env);

        /// <summary>
        ///  Registers a template with the environment.
        ///
        ///  This returns `false` if the template is malformed.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_add_template", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_env_add_template(mj_env* env, byte* name, byte* source);

        /// <summary>
        ///  Removes a template from the environment.
        ///
        ///  This returns `false` if the template is malformed.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_remove_template", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_env_remove_template(mj_env* env, byte* name);

        /// <summary>
        ///  Clears all templates.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_clear_templates", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_env_clear_templates(mj_env* env);

        /// <summary>
        ///  Renders a template registered on the environment.
        ///
        ///  Takes ownership of the given context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_render_template", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* mj_env_render_template(mj_env* env, byte* name, mj_value ctx);

        /// <summary>
        ///  Renders a template from a named string.
        ///
        ///  Takes ownership of the given context.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_render_named_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* mj_env_render_named_str(mj_env* env, byte* name, byte* source, mj_value ctx);

        /// <summary>
        ///  Evaluate an expression.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_eval_expr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_env_eval_expr(mj_env* env, byte* expr, mj_value ctx);

        /// <summary>
        ///  Frees an engine allocated string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_str_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_str_free(byte* s);

        /// <summary>
        ///  Enables or disables the `lstrip_blocks` feature.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_set_lstrip_blocks", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_env_set_lstrip_blocks(mj_env* env, [MarshalAs(UnmanagedType.U1)] bool val);

        /// <summary>
        ///  Enables or disables the `trim_blocks` feature.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_set_trim_blocks", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_env_set_trim_blocks(mj_env* env, [MarshalAs(UnmanagedType.U1)] bool val);

        /// <summary>
        ///  Preserve the trailing newline when rendering templates.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_set_keep_trailing_newline", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_env_set_keep_trailing_newline(mj_env* env, [MarshalAs(UnmanagedType.U1)] bool val);

        /// <summary>
        ///  Reconfigures the syntax.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_set_syntax_config", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_env_set_syntax_config(mj_env* env, mj_syntax_config* syntax);

        /// <summary>
        ///  Sets the syntax to defaults.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_syntax_config_default", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_syntax_config_default(mj_syntax_config* syntax);

        /// <summary>
        ///  Reconfigures the undefined behavior.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_set_undefined_behavior", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_env_set_undefined_behavior(mj_env* env, mj_undefined_behavior val);

        /// <summary>
        ///  Enables or disables debug mode.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_set_debug", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_env_set_debug(mj_env* env, [MarshalAs(UnmanagedType.U1)] bool val);

        /// <summary>
        ///  Changes the recursion limit.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_env_set_recursion_limit", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_env_set_recursion_limit(mj_env* env, uint val);

        /// <summary>
        ///  Returns `true` if there is currently an error.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_err_is_set", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_err_is_set();

        /// <summary>
        ///  Clears the current error.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_err_clear", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_err_clear();

        /// <summary>
        ///  Prints the error to stderr.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_err_print", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_err_print();

        /// <summary>
        ///  Returns the error's debug info if there is an error.
        ///
        ///  The value must be freed with `mj_str_free`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_err_get_debug_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* mj_err_get_debug_info();

        /// <summary>
        ///  Returns the error's description if there is an error.
        ///
        ///  The value must be freed with `mj_str_free`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_err_get_detail", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* mj_err_get_detail();

        /// <summary>
        ///  Returns the error's current template.
        ///
        ///  The value must be freed with `mj_str_free`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_err_get_template_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* mj_err_get_template_name();

        /// <summary>
        ///  Returns the error's current line.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_err_get_line", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint mj_err_get_line();

        /// <summary>
        ///  Returns the error's kind
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_err_get_kind", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_err_kind mj_err_get_kind();

        /// <summary>
        ///  Creates a new none value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_none", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_none();

        /// <summary>
        ///  Creates a new undefined value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_undefined", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_undefined();

        /// <summary>
        ///  Creates a new string value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_string(byte* s);

        /// <summary>
        ///  Creates an new bytes value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_bytes", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_bytes(byte* b, nuint length);

        /// <summary>
        ///  Creates a new boolean value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_bool", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_bool([MarshalAs(UnmanagedType.U1)] bool value);

        /// <summary>
        ///  Creates a new u32 value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_u32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_u32(uint value);

        /// <summary>
        ///  Creates a new i32 value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_i32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_i32(int value);

        /// <summary>
        ///  Creates a new u64 value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_u64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_u64(ulong value);

        /// <summary>
        ///  Creates a new i64 value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_i64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_i64(long value);

        /// <summary>
        ///  Creates a new f32 value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_f32(float value);

        /// <summary>
        ///  Creates a new f64 value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_f64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_f64(double value);

        /// <summary>
        ///  Creates an empty object value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_object", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_object();

        /// <summary>
        ///  Creates an empty list value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_new_list", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_new_list();

        /// <summary>
        ///  Inserts a string key into an object value.
        ///
        ///  The value is moved into the object.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_set_string_key", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_value_set_string_key(mj_value* slf, byte* key, mj_value value);

        /// <summary>
        ///  Inserts a key into an object value.
        ///
        ///  The value is moved into the object.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_set_key", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_value_set_key(mj_value* slf, mj_value key, mj_value value);

        /// <summary>
        ///  Appends a value to a list
        ///
        ///  The value is moved into the list.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_append", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_value_append(mj_value* slf, mj_value value);

        /// <summary>
        ///  Returns the value kind.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_get_kind", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value_kind mj_value_get_kind(mj_value value);

        /// <summary>
        ///  Converts the value into a string.
        ///
        ///  The returned string needs to be freed with `mj_str_free`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_to_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* mj_value_to_str(mj_value value);

        /// <summary>
        ///  If the value is a string or bytes, returns it the pointer
        ///  to it, and the length.
        ///
        ///  Note that strings are not null terminated.  If you need that, use
        ///  `mj_value_to_str` which will also stringify non string values.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_as_bytes", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* mj_value_as_bytes(mj_value value, nuint* len_out);

        /// <summary>
        ///  Extracts an integer from the value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_as_i64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern long mj_value_as_i64(mj_value value);

        /// <summary>
        ///  Extracts an unsigned integer from the value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_as_u64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong mj_value_as_u64(mj_value value);

        /// <summary>
        ///  Extracts a float from the value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_as_f64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern double mj_value_as_f64(mj_value value);

        /// <summary>
        ///  Checks if the value is truthy
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_is_true", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_value_is_true(mj_value value);

        /// <summary>
        ///  Checks if the value is numeric
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_is_number", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_value_is_number(mj_value value);

        /// <summary>
        ///  Returns the length of the object
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_len", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong mj_value_len(mj_value value);

        /// <summary>
        ///  Looks up an element by an integer index in a list of object
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_get_by_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_get_by_index(mj_value value, ulong idx);

        /// <summary>
        ///  Looks up an element by a string index in an object.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_get_by_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_get_by_str(mj_value value, byte* key);

        /// <summary>
        ///  Looks up an element by a value
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_get_by_value", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value mj_value_get_by_value(mj_value value, mj_value key);

        /// <summary>
        ///  Iterates over the value.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_try_iter", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern mj_value_iter* mj_value_try_iter(mj_value value);

        /// <summary>
        ///  Yields the next value from the iterator.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_iter_next", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool mj_value_iter_next(mj_value_iter* iter, mj_value* val_out);

        /// <summary>
        ///  Ends the iteration and deallocates the iterator
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_iter_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_value_iter_free(mj_value_iter* iter);

        /// <summary>
        ///  Increments the refcount
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_incref", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_value_incref(mj_value* value);

        /// <summary>
        ///  Decrements the refcount
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_decref", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_value_decref(mj_value* value);

        /// <summary>
        ///  Debug prints a value to stderr
        /// </summary>
        [DllImport(__DllName, EntryPoint = "mj_value_dbg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void mj_value_dbg(mj_value value);


    }

    /// <summary>
    ///  Pointer to a MiniJinja environment.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct mj_env
    {
    }

    /// <summary>
    ///  Allows one to override the syntax elements.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct mj_syntax_config
    {
        public byte* block_start;
        public byte* block_end;
        public byte* variable_start;
        public byte* variable_end;
        public byte* comment_start;
        public byte* comment_end;
        public byte* line_statement_prefix;
        public byte* line_comment_prefix;
    }

    /// <summary>
    ///  Opaque value type.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct mj_value
    {
        public fixed ulong _opaque[3];
    }

    /// <summary>
    ///  Helps iterating over a value.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct mj_value_iter
    {
    }


    /// <summary>
    ///  Controls the undefined behavior of the engine.
    /// </summary>
    internal enum mj_undefined_behavior : uint
    {
        /// <summary>
        ///  The default, somewhat lenient undefined behavior.
        /// </summary>
        MJ_UNDEFINED_BEHAVIOR_LENIENT,
        /// <summary>
        ///  Complains very quickly about undefined values.
        /// </summary>
        MJ_UNDEFINED_BEHAVIOR_STRICT,
        /// <summary>
        ///  Like Lenient, but also allows chaining of undefined lookups.
        /// </summary>
        MJ_UNDEFINED_BEHAVIOR_CHAINABLE,
    }

    /// <summary>
    ///  The kind of error that occurred.
    /// </summary>
    internal enum mj_err_kind : uint
    {
        MJ_ERR_KIND_NON_PRIMITIVE,
        MJ_ERR_KIND_NON_KEY,
        MJ_ERR_KIND_INVALID_OPERATION,
        MJ_ERR_KIND_SYNTAX_ERROR,
        MJ_ERR_KIND_TEMPLATE_NOT_FOUND,
        MJ_ERR_KIND_TOO_MANY_ARGUMENTS,
        MJ_ERR_KIND_MISSING_ARGUMENT,
        MJ_ERR_KIND_UNKNOWN_FILTER,
        MJ_ERR_KIND_UNKNOWN_FUNCTION,
        MJ_ERR_KIND_UNKNOWN_TEST,
        MJ_ERR_KIND_UNKNOWN_METHOD,
        MJ_ERR_KIND_BAD_ESCAPE,
        MJ_ERR_KIND_UNDEFINED_ERROR,
        MJ_ERROR_KIND_BAD_SERIALIZTION,
        MJ_ERR_KIND_BAD_INCLUDE,
        MJ_ERR_KIND_EVAL_BLOCK,
        MJ_ERR_KIND_CANNOT_UNPACK,
        MJ_ERR_KIND_WRITE_FAILURE,
        MJ_ERR_KIND_UNKNOWN,
    }

    /// <summary>
    ///  The kind of a value.
    /// </summary>
    internal enum mj_value_kind : uint
    {
        MJ_VALUE_KIND_UNDEFINED,
        MJ_VALUE_KIND_NONE,
        MJ_VALUE_KIND_BOOL,
        MJ_VALUE_KIND_NUMBER,
        MJ_VALUE_KIND_STRING,
        MJ_VALUE_KIND_BYTES,
        MJ_VALUE_KIND_SEQ,
        MJ_VALUE_KIND_MAP,
        MJ_VALUE_KIND_ITERABLE,
        MJ_VALUE_KIND_PLAIN,
        MJ_VALUE_KIND_INVALID,
    }


}
